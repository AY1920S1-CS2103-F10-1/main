Import and export functionality are split into three commands:

1. `export`
2. `import-replace`
3. `import-merge`

==== Jackson Library

The current import and export features are built upon the the existing `Jackson` libraries,
in particular the `dataformat`, `databind` and `datatype` modules. Technical knowledge of the
`Jackson` library will be helpful for maintenance of feature, but is not necessary.

However, understanding `Jackson` 's `annotations` will be needed in order to extend export and import
functionality to cover new data fields or classes implemented in the future. They are explained
link:https://github.com/FasterXML/jackson-annotations/wiki[here].

==== Csv Processing

All of the data processing needed for this feature can be found in the `CsvUtil` file;
it is responsible for converting the data of `Person` objects into a .csv friendly `String` format
and vice versa. The actual reading and writing of .csv files is then done with existing
`FileUtil` functionality.

The conversion of `Person` objects to and from .csv formatted `Strings` are handled by
the `CsvMapper` and `CsvSchema` classes implemented in `dataformat`.

* The `CsvMapper` is responsible for managing custom configurations for the conversions.
For instance, it can toggle headers with `withHeader()` and skip unknown fields with the
`IGNORE_UNKNOWN` feature, both of which are used in the feature implementation.
* The `CsvSchema` object is created by a configured `CsvMapper` object and an `Object.class`,
in this case, `Person.class`. It dictates the scheme for how data in each column of the .csv
corresponds with the fields in the Object class. This schema can then be used to instantiate
a reader or a writer object.

The following functions are implemented:

1. Write a list of `Person` objects into a .csv file with specified `exportFileName`.
If successful, return the path of the written file.
2. Read a .csv file with specified `importFileName` and return a corresponding list of
`Person` objects.

==== Command Implementation

===== Export

The `export` command works by retrieving a list of `Person` objects from the `Model` and passing
it to `CsvUtil` to process and write into a .csv file. If provided with indexes, the `export`
feature can selectively export the `Person` objects that correspond to the specified indexes.
To facilitate the selective export functionality, the following methods were implemented in
`Model` and `AddressBook`.

* `Model#GetPersonsByIndexes(Set<Indexes>)` -- Retrieves and returns a list of `Person` objects
corresponding to the provided indexes from the `AddressBook` , if the indexes are valid.
* `AddressBook#GetPersonByIndex(Index)` -- Returns the `Person` object corresponding
to the specified index, if the index is valid.

If indexes are not specified in the command arguments, a list of all currently existing `Person`
objects will be retrieved with `Model#getStagedPersonList()`.

The `export` command MUST be provided with a desired file name for the .csv file. The .csv
file will be written to `/exports/filename.csv`. Existing files will NOT be overridden and
thus the provided file name cannot already exist in `/exports`.

The following diagram shows how an export command works:

image::ExportSequenceDiagram.png[]

===== ExportCommand Design Considerations

====== Aspect: File Overriding

* **Alternative 1 (current choice)**: Disallow overriding, file name provided must be new
** Pros: Existing .csv files will not be accidentally overridden. Prevents potential loss of data.
** Cons: Additional hassle for the user to delete files that they want to replace.

* **Alternative 2**: Allow overriding
** Pros: Conveniently replace existing, unused files.
** Cons: May accidentally override and lose important data.

===== Aspect: Illegal Characters in Data Fields

* **Alternative 1 (current choice)**: Disallow forbidden characters
** Pros: Exported .csv files are guaranteed to be in the correct format.
** Cons: Data fields cannot have commas, semi-colons, etc.

* **Alternative 2**: Allow forbidden characters
** Pros: Certain fields may be more accurately represented, i.e. addresses.
** Cons: The exported csv file may be bugged, i.e. have data in the wrong columns.
More developer work to code around detecting and escaping forbidden characters.

===== Import

The import commands work by reading a .csv file and converting it into a list of `Person`
objects by using `CsvUtil`. The list is then passed to `Model`. What happens next depends
on which variant of import is called.

====== `import-replace`

The `Model` will replace all existing `Person` data in the `AddressBook` with the data
of the new list of `Person` objects. To do this, the following was implemented:

* `Model#replaceStagedAddressBook(List<Person>)` -- Creates a new `AddressBook` object
containing the `Person` objects in the provided list. The old `AddressBook` stored in the
`Model` is then replaced with the new `AddressBook` by calling
`Model#setStagedAddressBook(AddressBook)`.

====== `import-merge`

WIP

===== Import Design Considerations

WIP


